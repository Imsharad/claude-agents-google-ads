Product Requirement Document (PRD): The "Growth-Tier" Ads Protocol Agent
1. Executive Summary
The Growth-Tier Ads Protocol Agent is a vertical-agnostic, intelligent system designed to automate the deployment of Google Ads campaigns for any high-value offer (Service, Education, SaaS, or Consultation). It enforces a strict financial protocol (spend ₹20k to unlock ₹20k credit) to lower CAC by 50%, while leveraging Generative AI to adapt creative strategy to the specific market vertical.

2. Core Philosophy: The Protocol vs. The Product
This agent does not just "run ads"; it executes a Financial & Strategic Protocol.

Financial Protocol: Spend exactly ₹20,000 in 60 days to maximize platform incentives.
Strategic Protocol: Move from validation (Micro-Budget) to optimization (Growth-Budget) using A/B testing and algorithmic bidding.
The Variable: The "Product/Service" is now a configuration input, not a hardcoded value.
3. System Architecture
3.1 Configuration Interface (Input Layer)
The agent shall accept a "Campaign Configuration" object to adapt to different verticals.

{
  "vertical_type": "EDUCATION | SAAS | SERVICE | E-COMMERCE",
  "offer_name": "String (e.g., AI Workshop, CRM Tool, Dental Implant)",
  "target_audience_broad": "String (e.g., Mid-Career Professionals, Sales VP)",
  "value_proposition_primary": "String (e.g., Save time, Increase revenue)",
  "monetization_model": "TRIPWIRE_UPSELL | DIRECT_SALE | LEAD_GEN | BOOK_CALL"
}
3.2 Intelligence Layer (The "Brain")
3.2.1 Universal Persona Segmentation
Instead of hardcoding "Manager/Freelancer", the agent dynamically breaks the target_audience_broad into 3 distinct psychological cohorts suitable for the specific vertical.

Logic: Identify 3 distinct purchase drivers (e.g., Status, Fear, Efficiency).
Output: 3 Ad Group themes optimized for the specific vertical.
3.2.2 Abstracted Asset Generation (The "Polarity Test")
The agent applies the "Polarity Test" to any vertical, testing two psychological extremes.

Angle A (The Pull): Desire, Gain, Efficiency (e.g., "Master AI", "Close More Deals", "Smile Confidently").
Angle B (The Push): Fear, Loss Aversion, FOMO (e.g., "Don't get replaced", "Stop losing leads", "Prevent tooth loss").
3.2.3 Dynamic Upsell/Bridging
The "Backend" logic adapts to the monetization_model.

For Education: Generates Webinar Transition Script.
For SaaS: Generates Demo Booking Nudge ("Stop struggling manually, let us show you...").
For Service: Generates Consultation Value Stack ("This audit is worth $500, free for you today").
3.3 Execution Layer (The Campaign Manager)
3.3.1 Growth-Tier Financial Constraints
Global Rule: Daily Budget = Total Budget / 30. (Standard: ₹660/day).
Bidding Rule: "Maximize Clicks" with Cap.
Cap Logic: Cap = Max acceptable CPA / Estimated Conversion Rate (Dynamically calculated or defaulted to ₹50).
3.3.2 Keyword Expansion Protocol
Constraint: Use "Phrase Match" to capture intent variation.
Safety: Auto-deploy "Universal Negative List" (free, cheap, crack, job) + "Vertical Specific Negatives" (generated by LLM).

3.4 Claude Agent SDK Architecture
This section defines the technical implementation of the autonomous agent runtime, based on architectural decisions from research phase 1 (see research_summary.md).

3.4.1 SDK Initialization & Configuration
The agent is initialized using the stateful `ClaudeSDKClient`, which maintains session history and tool configurations.

**Key Configuration (`ClaudeAgentOptions`)**:
- **`model`**: `claude-3-5-sonnet-20241022` or latest.
- **`max_turns`**: Set to `30` to allow for complex, multi-step optimization workflows.
- **`system_prompt`**: Loaded from YAML templates to define the agent's core operational logic and constraints (see Section 3.5).
- **`mcp_servers`**: Registers the in-process Google Ads tool server.
- **`allowed_tools`**: Explicitly whitelists callable tools using the format `mcp__{server_name}__{tool_name}`.

```python
# Foundational agent configuration
from claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions

agent_options = ClaudeAgentOptions(
    model="claude-3-5-sonnet-20241022",
    max_turns=30,
    system_prompt=load_prompt_template("prompts/optimization_agent.yaml")["system"],
    mcp_servers={"google_ads": google_ads_mcp_server},
    allowed_tools=[
        "mcp__google_ads__get_campaign_metrics",
        "mcp__google_ads__update_campaign_budget"
        # ... other whitelisted tools
    ]
)
```

3.4.2 MCP Server Architecture: In-Process Topology
The agent uses an **In-Process MCP Server** to provide tools to the Claude agent. This architecture is critical for sharing the authenticated `GoogleAdsClient` object, eliminating IPC overhead, and centralizing secret management.

**Implementation Pattern**:
An instance of the `GoogleAdsClient` is created once and passed to the tool functions, ensuring efficient reuse of the authenticated session. Tool functions are designed to be resilient, catching any underlying API or network exceptions. Errors are not propagated as unhandled exceptions, which would crash the agent. Instead, they are returned as a structured error message within the tool's output. This allows the agent to reason about the failure (e.g., "The Google Ads API is temporarily unavailable, I will retry in 5 minutes.") and continue its task or degrade gracefully.

```python
from claude_agent_sdk import create_sdk_mcp_server, tool

# Shared Google Ads client (initialized once, reused by all tools)
google_ads_client = GoogleAdsClient.load_from_storage("google-ads.yaml")

@tool
def get_campaign_metrics(customer_id: str, campaign_id: str) -> dict:
    """Fetch performance metrics for a campaign."""
    # Direct access to shared client instance
    ga_service = google_ads_client.get_service("GoogleAdsService")
    # ... GAQL query logic ...
    return {"impressions": 1234, "clicks": 56, "cost_micros": 789000}

# Create in-process MCP server
google_ads_mcp_server = create_sdk_mcp_server(
    name="google_ads",
    tools=[get_campaign_metrics, update_campaign_budget]
)
```

3.4.3 Permission Handling: Custom `can_use_tool` Callback
Standard permission modes like `'ask'` are insufficient for a headless agent. A custom `can_use_tool` callback is implemented to enforce a 3-tier safety model, providing granular control over tool execution.

**3-Tier Safety Model**:
1.  **Auto-Deny**: Permanently block destructive operations (e.g., `DeleteCampaign`).
2.  **Auto-Allow**: Permit safe, read-only operations (e.g., `GetCampaignMetrics`).
3.  **Conditional/Ask**: For financial mutations (e.g., `UpdateBudget`), check against thresholds. In a headless environment, this denies the request and queues it for human approval via a separate interface.

**Implementation Pattern**:
```python
from claude_agent_sdk import PermissionResultAllow, PermissionResultDeny

async def google_ads_permission_controller(tool_name: str, tool_input: dict):
    """
    Custom permission callback for Google Ads mutations.
    Implements 3-tier safety: Auto-Deny, Auto-Allow, Conditional.
    """
    # Tier 1: DENY - Destructive operations always blocked
    BLOCKED_TOOLS = ["mcp__google_ads__delete_campaign", "mcp__google_ads__delete_ad_group"]
    if tool_name in BLOCKED_TOOLS:
        return PermissionResultDeny(message="Destructive operations are permanently disabled.")

    # Tier 2: ALLOW - Read-only operations (no financial impact)
    READ_ONLY_PREFIXES = ["mcp__google_ads__get_", "mcp__google_ads__search_"]
    if any(tool_name.startswith(prefix) for prefix in READ_ONLY_PREFIXES):
        return PermissionResultAllow()

    # Tier 3: CONDITIONAL - Budget changes require checks
    if tool_name == "mcp__google_ads__update_campaign_budget":
        budget_change = tool_input.get("new_budget_micros", 0) - tool_input.get("current_budget_micros", 0)
        if budget_change > 5000000:  # > ₹5 change
            # For headless: Deny + Queue for human approval
            return PermissionResultDeny(message="Budget changes > ₹5.00 require human approval.")
        return PermissionResultAllow()  # Small changes are auto-approved.

    # Default: Deny unknown tools as a fail-safe
    return PermissionResultDeny(message="Tool not recognized by security policy.")
```

3.4.4 Session Management: Daily Session Pattern
To avoid context drift and excessive token costs over long-running operations (7+ days), the agent uses a **Daily Session Pattern**.

-   A new `session_id` is created for each 24-hour operational cycle.
-   A summary of the previous day's actions and results is injected into the initial prompt of the new session to provide continuity.
-   This pattern isolates failures, keeps context windows clean, and aligns with the daily reporting cadence of Google Ads.

3.4.5 Persistence Architecture: Sidecar Database
A critical limitation of the SDK is the "Invisible History" problem: on session resumption, the LLM recalls context, but the client does not re-emit past message events. To solve this, a **Sidecar Persistence Pattern** is used.

-   **Event Interception**: Every event (`UserMessage`, `AssistantMessage`, `ToolUse`, `ToolResult`) is captured by the application wrapper.
-   **External Storage**: Events are immediately written to a durable database (e.g., PostgreSQL).
-   **History Reconstruction**: The UI and logs are populated from this external database, ensuring a complete and auditable history of agent actions, independent of the SDK's internal state.

3.4.6 System Prompt Structure & Strategy
The agent's "operating system" is defined by a system prompt loaded from a YAML file. This prompt establishes the agent's persona, constraints, and operational workflow.

-   **Role Definition**: "You are a conservative Google Ads optimization agent."
-   **Behavioral Constraints**: "NEVER delete campaigns. Obtain approval for budget increases > 10%."
-   **Workflow Definition**: A step-by-step guide on how to approach an optimization task (e.g., "1. Check metrics, 2. Identify anomalies, 3. Propose changes...").
-   **Dynamic Context**: The initial user message, not the system prompt, is used to inject dynamic, real-time data like daily performance summaries or critical alerts.
-   **Example Interaction**:
    *   **User**: "Please check the performance of the 'Summer Sale' campaign."
    *   **Agent (Tool Use)**: Calls `get_campaign_metrics` with `campaign_name='Summer Sale'`.
    *   **Agent (Response)**: "The 'Summer Sale' campaign has a CTR of 3.5% and a CPC of $1.20. I recommend increasing the budget to capture more traffic."

3.5 Gather-Action-Verify Agent Loop
This section defines the core recursive reasoning loop for all campaign management operations. The agent will follow this pattern to ensure that every change is intentional, verified, and safe. This loop is designed to operate within a daily session pattern, as defined in the Session Management section, to maintain context and control costs.

### Loop Phases

#### GATHER:
- **Collect current campaign state:** The agent retrieves the latest configuration and status of all relevant campaigns, ad groups, and keywords.
- **Fetch performance metrics:** The agent queries the Google Ads API for key performance indicators (KPIs) such as impressions, clicks, cost, conversions, and CTR.
- **Identify optimization opportunities:** The agent analyzes the gathered data to identify areas for improvement, such as underperforming keywords, budget allocation issues, or opportunities for bid adjustments.

#### ACTION:
- **Execute single atomic change:** The agent executes a single, atomic change to the campaign, such as pausing a keyword, increasing a bid, or updating ad copy. This ensures that the impact of each change can be isolated and verified.
- **Log action with timestamp:** Every action taken by the agent is logged with a timestamp and a description of the change. This provides a clear audit trail and is essential for debugging and performance analysis.

#### VERIFY:
- **Confirm change applied:** The agent queries the Google Ads API to confirm that the change was successfully applied and that the new state matches the intended state.
- **Check for errors/policy violations:** The agent checks for any errors or policy violations that may have resulted from the change.
- **If failed: enter recovery sub-loop:** If the verification fails, the agent enters a recovery sub-loop to address the issue.

### Verification Requirements per Action Type
To ensure each action is verified correctly, the agent will use the following checks based on the action type:

| Action Type | Verification Steps | Google Ads Service | Key Fields to Check |
|---|---|---|---|
| **Pause Keyword** | Fetch the keyword criterion | `GoogleAdsService` | `campaign_criterion.status` == `PAUSED` |
| **Update Bid** | Fetch the ad group or keyword criterion | `AdGroupService` / `CampaignCriterionService` | `ad_group.cpc_bid_micros` or `criterion.cpc_bid_micros` matches the new value |
| **Add Negative Keyword** | Query for the new negative keyword | `GoogleAdsService` | `campaign_criterion.negative` is `true` and `criterion.keyword.text` matches |
| **Update Budget** | Fetch the campaign budget | `CampaignBudgetService` | `campaign_budget.amount_micros` matches the new value |
| **Pause Ad Group** | Fetch the ad group | `AdGroupService` | `ad_group.status` == `PAUSED` |
| **Update Ad Copy** | Fetch the ad | `AdService` | `ad.responsive_search_ad.headlines` and `descriptions` match the new content |

### Error Recovery Sub-Loop
If the verification phase detects a failure, the agent will initiate a recovery sub-loop with the following steps:
1. **Revert Change:** The agent will attempt to revert the failed change to restore the campaign to its previous state.
2. **Analyze Failure:** The agent will analyze the error messages and logs to determine the root cause of the failure.
3. **Notify User:** The agent will notify the user of the failed action and the steps taken to recover.
4. **Retry or Escalate:** Based on the analysis, the agent will either retry the action with a modified approach or escalate the issue to the user for manual intervention.

### Iteration Limits
To prevent infinite loops and runaway operations, the agent will adhere to the following iteration limits:
- **Max Iterations per Session:** The main Gather-Action-Verify loop will be limited to a maximum of 10 iterations per daily session.
- **Max Recovery Attempts:** The error recovery sub-loop will be limited to a maximum of 3 retry attempts for a single failed action.

### Session Management and Forking
The Gather-Action-Verify loop operates within the context of a daily session. For exploring multiple optimization strategies in parallel, the agent will utilize **Session Forking**. This allows the agent to simulate different series of actions in isolated branches, compare their projected outcomes, and then commit the most promising strategy to the main session for execution. This technique is particularly useful for A/B testing different ad copy, bidding strategies, or targeting parameters without affecting the live campaign until a decision is made.

4. Operational Workflows
4.1 "The Setup" (Day 0)
User provides Campaign Configuration.
Agent hallucinates 3 Sub-Personas & 2 Ad Angles.
Agent drafting the Campaign Structure (Keywords, Negatives, Ads).
User Review: User approves/edits the strategy.
4.2 "The Ramp" (Days 1-14)
Objective: Buy data.
Action: Force 50/50 rotation of Angle A vs Angle B.
Metric Check: Is CTR > 1%? If no, kill Angle, request new creative from Intelligence Layer.
4.3 "The Optimization" (Days 15+)
Objective: Cut fat.
Action 1: Identify "Losing Persona" (High CPC, Low Conv). -> Pause Ad Group.
Action 2: Identify "Winning Persona". -> Increase Bid Cap by 20%.
5. Deployment Scenarios (Examples)
Scenario A: The Workshop (Original Research)
Input: Education, "AI Workshop", Tripwire Model.
Output: Sub-Personas (Manager, Marketer, Freelancer), "Benefit vs Fear" Ads, Webinar Upsell Script.
Scenario B: The Local Service (e.g., Dentist)
Input: Service, "Invisalign", Lead Gen Model.
Output: Sub-Personas (The Bridals, The Professionals, The Parents), "Confidence vs Health Risk" Ads, "Free Consultation" Bridge.
Scenario C: Micro-SaaS
Input: SaaS, "Email Automation Tool", Free Trial Model.
Output: Sub-Personas (The Solo Founder, The Agency Owner, The Enterprise rep), "Save Time vs Stop Burning Cash" Ads, "14-Day Free Trial" Bridge.
6. Functional Requirements Summary

## Core Requirements

### REQ-1: Dynamic Configuration Payload
Accept dynamic Configuration payload with strict validation:
- Schema validation via Pydantic models
- Enum constraints for vertical_type and monetization_model
- Required field enforcement
- String length limits for user-facing text

### REQ-2: Variable-Injected LLM Prompts
LLM Prompt Templates must be variable-injected (not hardcoded text):
- Storage format: YAML files in prompts/ directory
- Variable placeholders: {vertical_type}, {offer_name}, {target_audience_broad}, {value_proposition_primary}
- Template switching: Logic to select appropriate prompt based on monetization_model
- Versioning: Track prompt versions for A/B testing

### REQ-3: Tier-Based Bidding Strategy
Bidding logic maps to Growth-Tier Protocol monetization models. The following table defines the precise mapping between the business objective and the Google Ads API configuration.

| Monetization Model | Bidding Strategy | Google Ads Setting |
|--------------------|------------------|-------------------|
| TRIPWIRE_UPSELL | Target CPA | MAXIMIZE_CONVERSIONS + target_cpa_micros |
| DIRECT_SALE | Target ROAS | TARGET_ROAS + target_roas |
| LEAD_GEN | Max Clicks | MAXIMIZE_CLICKS + cpc_bid_ceiling_micros |
| BOOK_CALL | Target CPA | MAXIMIZE_CONVERSIONS + target_cpa_micros |

#### Warm-up Strategy ("Cold Start" Constraint)
For new campaigns, especially those using Target CPA or Target ROAS, a "warm-up" period is required to gather sufficient conversion data. The system shall not apply a `target_cpa_micros` or `target_roas` value until the campaign has registered a minimum of 15 conversions. During this initial phase, the campaign should run on a `MAXIMIZE_CONVERSIONS` or `MAXIMIZE_CLICKS` strategy without a specific target to allow the algorithm to learn.

#### Learning Phase Protection
Once a smart bidding strategy is active, its learning phase must be protected to ensure performance stability. The automated system must adhere to the following rules:
- **Budget Changes**: Do not increase or decrease the campaign's daily budget by more than 20% in a single 24-hour period.
- **Target Changes**: Do not change the `target_cpa_micros` or `target_roas` value by more than 20% in a single 24-hour period.
- **Strategy Changes**: Do not change the bidding strategy of a campaign without resetting the warm-up and learning phase.

Violating these constraints can reset the bidding algorithm's learning model, leading to performance volatility.
### REQ-4: Hierarchical Reporting Structure
Reporting must group data by "Persona" and "Angle" regardless of vertical:
- Level 1 Queries: Campaign/AdGroup metrics (no keyword segment)
- Level 2 Queries: Keyword-specific (SEARCH campaigns only)
- Avoid implicit filtering by respecting Google Ads API constraints
- Handle privacy thresholds (null data for small audiences)

## API & Infrastructure Requirements

### REQ-5: Google Ads API Version & Authentication
- **API Version**: v22 or higher (proto_plus mode required)
- **Configuration File**: google-ads.yaml with structure:
  ```yaml
  developer_token: YOUR_DEV_TOKEN
  client_id: YOUR_CLIENT_ID
  client_secret: YOUR_CLIENT_SECRET
  refresh_token: YOUR_REFRESH_TOKEN
  login_customer_id: YOUR_MCC_ID (optional)
  use_proto_plus: True
  ```
- **Authentication Flow**: Installed Application flow (OAuth2) for initial setup
- **Token Storage**: Securely store refresh_token, auto-refresh access_token

### REQ-6: Policy Compliance Exception Handler
Implement Try-Catch-Exempt-Retry algorithm for policy violations:

1. **Catch**: Wrap all mutation operations (create campaign, upload ad, etc.) in try-catch
2. **Detect**: Check for `GoogleAdsException.error_code == policy_finding_error`
3. **Extract**: Parse `policy_topic_entries` from exception
4. **Exempt**: Construct `PolicyValidationParameter` with `ignorable_policy_topics`
5. **Retry**: Re-submit mutation with exemption parameter
6. **Escalate**: If retry fails, log detailed error and alert human operator

**Example Flow**:
```python
try:
    create_ad(customer_id, ad_copy)
except GoogleAdsException as ex:
    if ex.failure.errors[0].error_code.policy_finding_error:
        policy_topics = extract_policy_topics(ex)
        retry_with_exemption(customer_id, ad_copy, policy_topics)
    else:
        escalate_to_human(ex)
```

## Intelligence Layer Requirements

### REQ-7: LLM Persona Generation Schema
Output schema for persona objects:
```json
{
  "personas": [
    {
      "name": "The Status Seeker",
      "pain_point": "Feels overlooked for promotions",
      "purchase_driver": "Career advancement",
      "ad_group_name": "persona_status_seeker"
    }
  ]
}
```

### REQ-8: Ad Copy Format Validation
- Headlines: 30 characters maximum (hard constraint)
- Descriptions: 90 characters maximum (hard constraint)
- Policy pre-check: Avoid prohibited claims (e.g., "guaranteed", "free money")
- Language: Match customer account language setting

### REQ-9: Negative Keyword Management
- Universal Negative List: free, cheap, crack, torrent, download, job, career, hiring, apply
- Vertical-Specific Negatives: LLM-generated (minimum 10 per vertical)
- Funnel Sculpting: Tier 1 keywords added as negatives in Tier 2/3 campaigns
- Implementation: Use `SharedSetService` for universal list, `CampaignCriterionService` for campaign-level

## Monitoring & Optimization Requirements

### REQ-10: Golden Ratio Budget Scaler
Replace static budget formula with Fibonacci-based scaling:

**Decision Matrix** (based on LTV:CAC ratio):

| LTV:CAC Ratio | Action | Formula |
|---------------|--------|---------|
| < 1.0 | Pause Campaign | N/A |
| 1.0 - 2.9 | Maintain | Current Budget |
| 3.0 - 3.9 | Scale Moderately | Next = Current × 1.618 |
| 4.0+ | Scale Aggressively | Next = Current × 2.618 |

**Circuit Breaker**: Max daily budget = ₹2,000 (prevent runaway spend)
**Exception**: Tripwire model campaigns exempt from pause rule (prioritize email capture)

### REQ-11: CTR Threshold Monitoring
- **Frequency**: Daily (not real-time due to API delay)
- **Threshold**: CTR < 1% with impressions > 100
- **Action**: Pause ad via `AdService.mutate(status=PAUSED)`
- **Trigger**: Request new creative variant from LLM (TASK-023)

### REQ-12: Conversion-Based Optimization
Define "Losing Persona":
- `cost_per_conversion > target_cpa` OR
- `conversions = 0 AND spend > ₹2,000`

**Action**: Pause ad group via `AdGroupService.mutate`

Define "Winning Persona":
- `cost_per_conversion < target_cpa` AND
- `conversions >= 5`

**Action** (depends on bidding strategy per REQ-3):
- Manual CPC: Increase keyword bids by 20%
- Maximize Clicks: Increase bid cap by 20%
- Target CPA/ROAS: No action (Smart Bidding auto-optimizes)

### REQ-13: Spend Pacing Monitor
Track progress toward ₹20k threshold:
- Query account-level spend daily
- Calculate required daily spend to hit ₹20k in 60-day window
- Alert user at milestones: ₹5k, ₹10k, ₹15k, ₹20k
- If underpacing: Recommend geo expansion or bid cap increase

## User Interaction Requirements

### REQ-14: Approval Workflow
Campaign setup must include user review gates:
- Agent generates: Keywords, Negatives, Ad Copy, Budget Plan
- User receives structured output (JSON or formatted text)
- User actions: `approve` | `edit` | `reject`
- On `reject`: Agent loops back to generation with user feedback
- Implementation: Claude SDK `permission_mode='ask'` for create_campaign tool

### REQ-15: Conversion Tracking Prerequisites
Before optimization (Phase 3), validate conversion tracking:
- Query existing conversion actions via `ConversionActionService`
- If none found: Provide setup instructions (website tag implementation)
- If found: Validate tracking is active (`impressions > 0` in last 7 days)
- Return `conversion_action` resource_name for reporting queries